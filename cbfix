#! /usr/bin/env python

import logging, rarfile, zipfile, re, os, sys, tempfile, shutil, argparse

#ROOT = '/tmp/x'
#ROOT = '/Users/mysterio/Documents/Comics/Marvel/Daredevil Vol 2'

COMIC_CBR_EXT = frozenset(['.cbr', '.rar'])
COMIC_CBZ_EXT = frozenset(['.cbz', '.zip'])
COMIC_EXT = COMIC_CBR_EXT | COMIC_CBZ_EXT

FINAL_NUMBER = re.compile(r'[^\d](\d+)\.[A-Za-z0-9]+$')
FOUR_NUM_END = re.compile(r'^(.*)(\d\d)(\d\d)\.([A-Za-z0-9]+)$')

EXTRACT_PREFIX = 'EXTRACT-'

def fixed_filename(filename):
    """Given a possibly bad filename, return a fixed version of it, or None
    if the filename is already correct"""
    res = FOUR_NUM_END.match(filename)
    if res is None:
        return None
    return res.expand(r'\1\2-\3.\4')

class FixerError(Exception): pass

class Comic(object):
    """Base class representing a single comic file"""
    def __init__(self, filename):
        self.filename = filename
        self.basename = os.path.basename(filename)
        self.bad_names = {}
        self.scan()

    def scan(self):
        max_num = 0
        min_num = sys.maxint
        bad_names = {}
        for comp_file in self.list_compressed_files():
            comp_file = comp_file.replace('\\', '/')
            last_num = FINAL_NUMBER.search(comp_file)
            if last_num is None:
                logging.debug('Scanner: skipping %s', comp_file)
                continue
            num_len = len(last_num.group(1))
            max_num = max(max_num, num_len)
            min_num = min(min_num, num_len)
            four_match = FOUR_NUM_END.match(comp_file)
            if four_match:
                bad_names[comp_file] = four_match.expand(r'\1\2-\3.\4')
        if max_num != 4 or min_num != 2:
            logging.debug('Skipping fix for %s because of peculiar numbering ' +
                          '(max %d, min %d)', self, max_num, min_num)
            return
        #logging.debug('hmm, %s: max %d, min %d, n %d', self, max_num, min_num, len(bad_names))
        self.bad_names = bad_names
        self.has_bad_names = True

    def fix_filenames(self, fixer):
        if not self.bad_names:
            logging.debug('No incorrect files found in %s', self)
            return
        logging.info('Fixing %d filenames in %s', len(self.bad_names), self)
        for old, new in self.bad_names.iteritems():
            pass
            #logging.debug('Renaming %s to %s', old, new)

    def __repr__(self):
        sz = ' ({})'.format(len(self.bad_names)) if self.bad_names else ''
        return '<"{0.basename}"{1}>'.format(self, sz)

    def list_compressed_files(self):
        with self.open_archive(self.filename) as compressed_file:
            return compressed_file.namelist()

    def extract_to(self, root):
        extract_dir = os.path.join(root, EXTRACT_PREFIX + self.basename)
        os.makedirs(extract_dir)
        logging.debug('Creating extract directory %s...', extract_dir)
        with self.open_archive(self.filename) as compressed_file:
            compressed_file.extractall(path=extract_dir)
            logging.debug('Extracted %s to %s', self.filename, extract_dir)
        return extract_dir

    def compress_from(self, extracted_path, root):
        new_archive_path = os.path.join(root, self.basename)
        logging.debug('Compressing extracted directory %s to %s',
                      extracted_path, new_archive_path)
        self.make_archive(extracted_path, new_archive_path)
        return new_archive_path

    def make_archive(self, extracted, archive_path):
        raise NotImplementedError('Subclasses must define make_archive()')

    def open_archive(self, filename):
        raise NotImplementedError('Subclasses must define open_archive()')

    def extension(self):
        raise NotImplementedError('Subclasses must define extension()')

    @staticmethod
    def makeComic(root, filename):
        """Factory method returning an appropriate Comic subclass based on the file
        type of the passed-in filename or None"""
        path = os.path.join(root, filename)
        if rarfile.is_rarfile(path):
            return RarComic(path)
        elif zipfile.is_zipfile(path):
            return ZipComic(path)
        else:
            logging.error('File "%s" is neither a rar nor a zip file, skipping it', path)
            return None

class RarComic(Comic):
    """Subclass representing a rar-compressed (CBR) file"""
    def __init__(self, filename):
        super(RarComic, self).__init__(filename)

    def extension(self): return '.cbr'

    def open_archive(self, filename): return rarfile.RarFile(filename)

    def make_archive(self, extracted, archive_path):
        raise FixerError('Error creating archive {} from {}: {}'.format(
                         archive_path, extracted, 'not implemented'))

class ZipComic(Comic):
    """Subclass representing a zip-compressed (CBZ) file"""
    def __init__(self, filename):
        super(ZipComic, self).__init__(filename)

    def extension(self): return '.cbz'

    def open_archive(self, filename): return zipfile.ZipFile(filename)

class Fixer(object):
    """Command class """
    def __init__(self, detect_only=False, keep_temp=False):
        self.root = None
        self.queue = []
        self.total_comics = 0
        self.total_renames = 0
        self.detect_only = detect_only
        self.keep_temp = keep_temp

    def scan_comics(self, root):
        comix = []
        for root, dirs, files in os.walk(root):
            comix += [Comic.makeComic(root, f) for f in files if looks_comicy(f)]
        return [c for c in comix if c is not None]

    def cleanup(self):
        if self.root is None: return
        if self.keep_temp:
            logging.info('Note, temp files exist in %s', self.root)
        else:
            logging.debug('Removing %s', self.root)
            shutil.rmtree(self.root)

    def getTemp(self):
        if self.root is None:
            self.root = tempfile.mkdtemp(prefix='cbfix-')
        return self.root

    def include(self, comic):
        """Include the given comic in the eventual fixing pass"""
        if not comic.bad_names:
            logging.debug('No incorrect files found in %s', comic)
        else:
            self.queue.append(comic)
            self.total_comics += 1
            self.total_renames += len(comic.bad_names)

    def fix_all(self):
        """Go through the list of previously included files and fix them"""
        if not self.queue:
            logging.info('No incorrect files found (scanned %d comic files).',
                         self.total_comics)
            return

        msg = '{} {} incorrect filenames in {} files.'.format(
            ('Detected' if self.detect_only else 'About to fix'),
            self.total_renames, self.total_comics)
        logging.info(msg)
        for comic in self.queue:
            logging.info('Found %d incorrect files in %s',
                         len(comic.bad_names), comic)
            if not self.detect_only:
                try:
                    self.fix_comic(comic)
                except FixerError as e:
                    logging.error(e.args[0])

    def fix_comic(self, comic):
        """Fix a single comic boox file"""
        # Extract file
        try:
            cb_path = comic.extract_to(self.getTemp())
        except OSError as e:
            raise FixerError('Error extracting {} to {}: {}'.format(
                             comic, self.getTemp(), e), e)
        # Rename bad files
        for old, new in comic.bad_names.iteritems():
            old_path, new_path = os.path.join(cb_path, old), os.path.join(cb_path, new)
            logging.debug('Renaming %s to %s', old, new)
            try:
                os.rename(old_path, new_path)
            except OSError as e:
                raise FixerError('Error renaming {} to {}: {}'.format(
                                 old_path, new_path, e), e)
        # Re-compress file
        new_path = comic.compress_from(cb_path, self.getTemp())
        logging.info('Fixed comic recompressed as %s', new_path)

def looks_comicy(filename):
    """Simple filter returns True if a filename has a comic extension"""
    return os.path.splitext(filename)[1].lower() in COMIC_EXT

def main():
    parser = argparse.ArgumentParser(description='Fix cbr/cbz page numbering')
    parser.add_argument('root', help='Root directory to scan')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='Produce verbose output')
    parser.add_argument('-d', '--detect', action='store_true',
                        help='Detect bad filenames, but do not fix anything')
    parser.add_argument('-k', '--keep', action='store_true',
                        help='Keep temporary files around after run')
    opts = parser.parse_args()

    level = logging.DEBUG if opts.verbose else logging.INFO
    logging.basicConfig(level=level, format='%(message)s')

    fixer = Fixer(detect_only=opts.detect, keep_temp=opts.keep)
    try:
        for comic in fixer.scan_comics(opts.root):
            fixer.include(comic)
        fixer.fix_all()
    finally:
        fixer.cleanup()

if __name__ == '__main__': main()
